"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPackages = getPackages;

var _traverse = _interopRequireDefault(require("@babel/traverse"));

var t = _interopRequireWildcard(require("@babel/types"));

var _parser = require("@babel/parser");

var _parser2 = require("./parser");

var PARSE_PLUGINS = ['jsx', 'asyncFunctions', 'classConstructorCall', 'doExpressions', 'trailingFunctionCommas', 'objectRestSpread', ['decorators', {
  decoratorsBeforeExport: true
}], 'classProperties', 'exportExtensions', 'exponentiationOperator', 'asyncGenerators', 'functionBind', 'functionSent', 'dynamicImport'];
var PARSE_JS_PLUGINS = ['flow'].concat(PARSE_PLUGINS);
var PARSE_TS_PLUGINS = ['typescript'].concat(PARSE_PLUGINS);

function getPackages(fileName, source, language) {
  var lineOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var packages = [];
  var visitor = {
    ImportDeclaration: function ImportDeclaration(_ref) {
      var node = _ref.node;

      if (node.importKind !== 'type') {
        packages.push({
          fileName: fileName,
          name: node.source.value,
          line: node.loc.end.line + lineOffset,
          string: compileImportString(node)
        });
      }
    },
    CallExpression: function CallExpression(_ref2) {
      var node = _ref2.node;

      if (node.callee.name === 'require') {
        packages.push({
          fileName: fileName,
          name: getPackageName(node),
          line: node.loc.end.line + lineOffset,
          string: compileRequireString(node)
        });
      } else if (node.callee.type === 'Import') {
        packages.push({
          fileName: fileName,
          name: getPackageName(node),
          line: node.loc.end.line + lineOffset,
          string: compileImportExpressionString(node)
        });
      }
    }
  };
  var ast = parse(source, language);
  (0, _traverse["default"])(ast, visitor);
  return packages;
}

function parse(source, language) {
  var plugins = language === _parser2.TYPESCRIPT ? PARSE_TS_PLUGINS : PARSE_JS_PLUGINS;
  return (0, _parser.parse)(source, {
    sourceType: 'module',
    plugins: plugins
  });
}

function compileImportString(node) {
  var importSpecifiers, importString;

  if (node.specifiers && node.specifiers.length > 0) {
    importString = [].concat(node.specifiers).sort(function (s1, s2) {
      // Import specifiers are in statement order, which for mixed imports must be either "defaultImport, * as namespaceImport"
      // or "defaultImport, { namedImport [as alias]... } according to current ECMA-262.
      // Given that two equivalent import statements can only differ in the order of the items in a NamedImports block,
      // we only need to sort these items in relation to each other to normalise the statements for caching purposes.
      // Where the node is anything other than ImportSpecifier (Babel terminoligy for NamedImports), preserve the original statement order.
      if (t.isImportSpecifier(s1) && t.isImportSpecifier(s2)) {
        return s1.imported.name < s2.imported.name ? -1 : 1;
      }

      return 0;
    }).map(function (specifier, i) {
      if (t.isImportNamespaceSpecifier(specifier)) {
        return "* as ".concat(specifier.local.name);
      } else if (t.isImportDefaultSpecifier(specifier)) {
        return specifier.local.name;
      } else if (t.isImportSpecifier(specifier)) {
        if (!importSpecifiers) {
          importSpecifiers = '{';
        }

        importSpecifiers += specifier.imported.name;

        if (node.specifiers[i + 1] && t.isImportSpecifier(node.specifiers[i + 1])) {
          importSpecifiers += ', ';
          return undefined;
        } else {
          var result = importSpecifiers + '}';
          importSpecifiers = undefined;
          return result;
        }
      } else {
        return undefined;
      }
    }).filter(function (x) {
      return x;
    }).join(', ');
  } else {
    importString = '* as tmp';
  }

  return "import ".concat(importString, " from '").concat(node.source.value, "';\nconsole.log(").concat(importString.replace('* as ', ''), ");");
}

function compileRequireString(node) {
  return "require('".concat(getPackageName(node), "')");
}

function compileImportExpressionString(node) {
  return "import('".concat(getPackageName(node), "').then(res => console.log(res));");
}

function getPackageName(node) {
  return t.isTemplateLiteral(node.arguments[0]) ? node.arguments[0].quasis[0].value.raw : node.arguments[0].value;
}